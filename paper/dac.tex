\documentclass[journal]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{natbib}
\usepackage{hyperref}
\usepackage{enumitem}
\colorlet{punct}{red!60!black}
\definecolor{background}{HTML}{EEEEEE}
\definecolor{delim}{RGB}{20,105,176}
\colorlet{numb}{magenta!60!black}

% correct bad hyphenation here
\hyphenation{op-tical net-works semi-conduc-tor}

\begin{document}

\title{Delegated Anonymous Credentials with Revocation Capability for IoT Service Chains}
\author{\IEEEauthorblockN{\textsf{Sandeep Kiran Pinjala}$^{1,2}$ and
    \textsf{Krishna     M. Sivalingam}$^1$}

\IEEEauthorblockA{\textit{$^1$Dept. of Computer Science and
    Engineering, Indian Institute of Technology Madras, Chennai, India} \\ 
\textit{$^2$HCL Technologies, Chennai, India} \\
\texttt{\footnotesize{Email: sandeepkiranp@gmail.com, cs16s001@smail.iitm.ac.in,
skrishnam@iitm.ac.in, krishna.sivalingam@gmail.com}}
}}

\IEEEoverridecommandlockouts
\IEEEpubid{\makebox[\columnwidth]{978-1-5386-4980-0/19/\$31.00
    \copyright2019 IEEE} \hspace{\columnsep}\makebox[\columnwidth]{ }}

\maketitle

\begin{abstract}
The abstract goes here.
\end{abstract}

% Note that keywords are not normally used for peerreview papers.
\begin{IEEEkeywords}

\end{IEEEkeywords}



\IEEEpeerreviewmaketitle



\section{Introduction} \label{introduction}

Internet of Things (IoT) enables physical objects also called \textit{Things}  to communicate with each other and to their human operators. This opens up a myriad of use cases such as smart homes, smart factories, smart cities, smart healthcare, smart grids etc \cite{IoT}. It is also expected that such connected devices could reach upto 50 billion by 2020 \cite{Evans}. The IoT devices (for example, a smart bulb or a temperature sensor) are very constrained in terms of memory, processing power, storage and most often are battery powered. Unlike the traditional computers these devices cannot perform computationally intensive tasks and are intended for minor operations of sensing and actuation. Also most of these devices are out in the open without any physical supervision making them easily susceptible to physical attacks.

Owing to the resource constraints and physical openness, IoT devices have been targets of various attacks \cite{iot-sec} at physical, network and application layer. IoT devices also collect lot of personal information like user's location, eating habits, medical history etc because of which there has been a growing concern among consumers of such services. Unlike normal computers, these devices cannot provide an interface where the user can look up what personal information is being shared and with whom. In \cite{Ziegeldorf2014PrivacyIT} the authors define privacy in IoT as a guarantee for the subject	

\begin{enumerate}[label=\alph*)]
	\item To be aware of the privacy risks imposed by smart things.
	\item Control over collection and processing of personal information
	\item Control over subject's personal information being disseminated outside of his control sphere.
\end{enumerate}
They then categorize privacy threats and challenges of IoT into a) Identification b) Localization and tracking c) Profiling d) Privacy-violating interaction and presentation e) Inventory and life cycle tracking and f) linkage.

IoT services do not act in silos. They interact with each other and with external entities to provide a complete package of services to the user. For example, in Home Automation, based on the user who is entering the house (say Owner vs Guest), a completely different set of services may get invoked. The service interactions and invocations depend on the roles and capabilities of the user invoking them. We call the sequence of services that get invoked as \textit{IoT Service Chain}. In this paper we look at providing security and privacy to users and IoT devices that invoke IoT service chains. The rest of the paper is organized as follows. Section 2...... Section 3... Section 4..

\section{Motivation and related work}

\subsubsection{IoT Service Chains} \label{iotsvcch}
We introduced \textit{IoT Service Chains} in section \ref{introduction} to refer to the chain of services invoked when an event occurs. Individual services in the chain interact with each other, on-behalf of the initiator towards a common goal. Initiator could either be a human or an IoT device. Each service in the chain would in-turn validate the user/IoT device's credentials for the desired service functionality. IoT devices can either act on behalf of their operator or can be independent of it. For example, if a smart Heart Monitoring System (HMS) detects a low pulse rate for a patient, it immediately needs to initiate the Advanced Cardiac Life Support (ACLS) by injecting an IV of an antidote, reading and interpreting the ECG, starting CPR, inform the doctor etc. The HMS in this case acts as an independent device and does not impersonate the patient. But in case of a smart fridge, which keeps track of the stock of milk, it automatically places an order for replenishment by using the owners credit card details. In this case, the smart fridge acts on behalf of the owner.

\begin{figure}[htbp]
\centerline{\includegraphics[width=3in]{dac.png}}
\caption{IoT Service Chain}
\label{fig:iotsvc}
\end{figure}

As can be seen in Fig.~\ref{fig:iotsvc} there are 5 services in the IoT service chain. xxxx explanation of HMS, ACLS etc interactions among services, authentication etc

One thing to notice from the above figure is that while the service chain is being invoked, the user/IoT device has to be online so that it supplies the necessary credentials for authentication and authorization.  This isn't a huge problem if the initiating entity is a user (having a smart phone or a tablet). But for a constrained IoT device generating authentication and authorization information for each service in the chain would result in draining of its resources very quickly. Also, most of the IoT devices are duty cycled and may not remain active till the chain completes. This again results in loss of packets or in retransmission. It will be even more challenging if the user/device's privacy needs to be protected through out the chain. In this paper we focus on some of the options on how device privacy can be ensured when invoking the service chain without pushing the device to its resource limits.

\subsubsection{Attribute Based Anonymous Credentials}
In traditional credential based system, a central authority grants credentials to users and systems. These credentials can be password or token (certificate) based. When the user wants to access a resource he presents the credential to it which inturn validates the credential. The resource (also called service) trusts the central authority and thereby the credentials issued by it. Once the credential verification is done, the service checks whether the user has got the right access level to access the resource. One of the primary concern with such a system is that the service gets to know the complete details of the user presenting the credential. for example, in public key certifcates issued to users, the service will know how long the credential (certificate in this case) is valid, the country, state, organization, email address etc of the user, who are all the intermediate chain of issuers etc. The only information that matters to the service is whether the certificate is valid and is issued by the central authority and whether the user possesses the required access right. But in this case lot more user details are available to it. With so much personal information available to the service, there is always a chance of misuse of data if it falls in wrong hands. According to European Union General Data Protection Regulation (GDPR) Data Minimization principle, entities should only process adequate, relevent and limited personal data that is necessary in relation to the purposes for thish they are processed. As mentioned in \cite{Ziegeldorf2014PrivacyIT}, the privacy problem becomes manifold in IoT world. One, because there are huge number of constrained IoT devices without proper security measures in place. And two, there is very little control over what personal information is disseminated from these devices to the outside world.

Anonymous Credentials introduced in \cite{chaum83blindsign} provide a way in which the user can prove that he holds a credential without revealing any information about the user. The verifier cannot also forge the user's credential. In Attribute  Based Anonymous Credentials, the user can selectively prove that he holds the set of attributes needed by the verifier and not reveal all of his attributes, thereby maintaining privacy. The prover creates a zero-knowledge proof of possession of the credential which the verifier verifies using the public key of the central authority. Some of the most popular Anonymous Credential Systems (ACS) are \cite{CamenischH02} and \citep{uprove}.

A Delegatable Anonymus Credential (DAC) System, introduced in \cite{delegatabledac}  not only allows the users to generate anonymous credentials, but also allows them to anonymously delegate their credentials to other entities. For example, in a hierarchical setup, the root issuer may delegate its issuing authority to region wise issuers who in turn may delegate to division wise issuers and so on. Although there can be multiple levels of delegation, the anonymous credential generated by the prover at any level can only be verified by the public key of the root issuer.  One of the primary advantages of DAC is that it alleviates the burden on the root issuer to issue credentials but still maintains anonymity of all the issuers in the chain.

\subsubsection{Our Contribution}
In section \ref{iotsvcch} we talked about IoT service chains and the difficulty of ensuring user/IoT device's privacy during the chain propagation. We address this problem with our proposal on \textbf{\textit{Delegated Anonymous Credentials in IoT Service Chains}}. We describe a mechanism in which the IoT device can delegate its credentials to a controller which in turn generates an anonymous credential based on the attributes needed by the service. Our scheme is based on the DAC system developed by Camenisch \textit{et al.} \cite{CamenischDD17}. The authors developed a scheme where credentials are not delegated anonymously but the prover anonymously proves that the entire chain of delegation is valid. The verifier verifies the anonymous credential just with the root issuer's public key.

The following are major contributions in this work.
\begin{enumerate}[label=\alph*)]
	\item Discuss in detail the problem of ensuring privacy to users and IoT devices in IoT service chains.
	\item Implementation of the DAC scheme outlined in \cite{CamenischDD17}. We used the Pairing Based Cryptography Library from \cite{pbc} for the implementation. We implemented the full L-level credential Delegation, Presentation and Verification.
	\item Credential revocation has been mentioned as "future work" in \cite{CamenischDD17}. We implemented revocation of credentials in our scheme.
	\item Once the verifier verifies the anonymous credential token, the next logical step would be to communicate with the prover to exchange data. In order to do that securely, a common session key needs to be established between the two parties. We demonstrate how the session key can be established.
	\item We then used the above DAC implementation to realize Delegated Anonymous Credentials in IoT service chains. We outline the framework consisting of Root issuer, Controller, User/IoT device and Service as the principal components. We describe the messages exchanged between these components and outline how privacy of users can be ensured.
	\item We implemented the above scheme and discuss the various possibilities on how token verification and policy implementation can be placed across constrained IoT services. Various metrics like time taken, number and size of messages exchanged, memory, CPU etc are evaluated for the various models that we discuss. 
\end{enumerate}

\subsubsection{Related Work}
Subsubsection text here.

\section{Preliminaries}
In this section we introduce some of the concepts related to DAC building blocks. 

\subsubsection{Bilinear map}
A Bilinear map is a Pairing-Based Cryptography construct that allows us to build and analyze cryptographic systems. Let $G_1$, $G_2$  and $G_T$ be multiplicative groups of order $q$, then a bilinear map e $: G_1 X G_2\rightarrow G_T$ satisfies the following properties

\textbf{Bilinearity}

$$\forall P \in G_1, \forall Q \in G_2 : e(P^a, Q^b) = e(P,Q)^{ab}$$

\textbf{Non-Degeneracy}
$$ A \neq 0 \Rightarrow e(A,A) \neq 1$$

\textbf{Computability}

 e is efficiently computable


\subsubsection{Zero Knowledge Proofs}
Zero knowledge Proofs (ZKP), introduced in \cite{zkp} allow the prover to prove that he knows certain information without revealing the information (or anything related to it) to the verifier. A ZKP should be complete, sound and should not reveal any information from teh proof. A zero-knowledge proof of knowledge is a special case where the prover possesses a secret information and not just the knowledge of it. Interactive ZKP require interaction between the prover and the verifier to prove that the prover has the secret information. For example, the Schnorr ZKP is outlined in \cite{rfc8235}. The Non-Interactive ZKP (NIZKP) proofs do not require any kind of interaction for the proof to proceed. The Schnorr NIZKP proof is obtained through the Fiat-Shamir transformation \cite{Fiat1986HowTP}.

\subsubsection{Signature Schemes}
A signature scheme consists of the following algorithms.
\begin{enumerate}[label=\alph*)]
	\item Setup : Given the security parameter, the algorithm outputs public parameters.
	\item Key Generation : This algorithm generates a public key and the corresponding private key based on the public parameters.
	\item Signature Generation : This algorithm takes the private key and the message and outputs the signature. The generated signature should not be forge-able.
	\item Signature Verification : This algorithm takes the signature, public key and the message and output whether the verification is successful or not.
	
\cite{CamenischDD17} uses Groth's structure preserving signature scheme \cite{groth} where the public keys, messages to be signed and the signatures are all elements of group $G1$ or $G2$.

\end{enumerate}

\section{DAC By Camenisch \textit{et al.} \cite{CamenischDD17} and our extensions}
The authors in \cite{CamenischDD17} built a practical attribute based DAC system of L-level hierarchy where the delegation is not anonymous. The delegator reveals its identity and the identity of the entire chain to the delegatee during the delegation process. It is only during the presentation of the anonymous credential, the prover hides the identity of all the intermediate delegators. The prover also selectively reveals attributes at each level of delegation. The verifier in turn uses the root issuer's public key to verify the anonymous credential token. The authors also describe the instantiation of their DAC system based on Groth \cite{groth} and Schnorr \cite{rfc8235} schemes. The authors introduce a new signature scheme called \textit{sibling signatures} which allows a users with a single key pair with two different signature schemes. This single key pair can be used both during delegation and token presentation.

\begin{figure}[htbp]
\centerline{\includegraphics[width=3in]{dac.png}}
\caption{Generic Construction of Camenisch \textit{et al.} \cite{CamenischDD17}}
\label{fig:genconst}
\end{figure}

The author's generic construction scheme is depicted in Fig. \ref{fig:genconst}.At Level-0 is the root issuer with public, private key pair as $(ipk,isk)$. The root issuer delegates certain attributes $\overrightarrow{a_1}$ to say $user1$ at Level-1 with key pair as $(cpk_1, csk_1)$. It generates a signature ($\sigma_1$) on the combination of $(cpk_1,\overrightarrow{a_1})$ using $isk$. It passes on the signature and attributes to  $user1$. Similarly, if $user1$ at Level-1 wants to delegate certain attributes $\overrightarrow{a_2}$ to $user2$ with key pair $(cpk_2, csk_2)$, it generates a signature ($\sigma_2$) using $csk1$ over $(cpk_2,\overrightarrow{a_2})$. $user2$ then forwards the ($\sigma_1$), $\overrightarrow{a_1}$ and $cpk_1$ generated at Level-1 as well as ($\sigma_2$), $\overrightarrow{a_2}$ generated at Level-2 to $user2$. This goes on till any Level$-l$ credential. So a Level-l credential is a combination of all signatures, attributes and public keys of all $l-1$ levels and Level-$l$ private key.

In order to anonymously present a credential at any level, the prover generates a NIZKP proof proving that he holds the entire credential chain (signatures, attributes and public keys at each level). He can selectively reveal attributes at each level. The public keys (and thereby the identity of users) at each level will remain hidden. The verifier verifies the token using just the root issuers public key. The authors provided an instantiation of their construction scheme using Bilinear Pairings and Groth-Schnorr sibling signatures. They used Groth1 to denote Groth signatures on messages in $G1$ with public key in $G2$ (called SibGS1) and Groth2 to denote Groth signatures on messages in $G2$ with public key in $G1$ (called SibGS2). The final attribute token would then look like

$$
at \leftarrow NIZK \lbrace(  )\rbrace
$$

In order to prove that the prover holds the private key corresponding to the public key at Level-L($cpk_L$), the NIZK proof also includes the proof for a message $m$ signed with the private key at Level-L ($csk_L$).

\subsubsection{Credential Revocation}
One of the important functionalities of any credential based system is to account for revoked credentials. Revocation allows the administrator to stop rouge elements from entering into the system. The authors in \citep{CamenischDD17} left out credential revocation as a future item. In this section we discuss how credential revocation can be achieved using the author's concrete instantiation.

As mentioned in the previous section, if a user at level K-1 wants to delegate certain attributes ($\overrightarrow{a_K}$) to another user, he signs the message $(cpk_K,\overrightarrow{a_K})$ with $csk_{K-1}$. We propose to extend the signature message to include a Hash of $(cpk_K , \overrightarrow{a_K})$. We call this hash as the credential hash at level K. Therefore,

$$
h_K = Hash(cpk_K,\overrightarrow{a_K})
$$
$$
\sigma_K = Sign_{csk_{K-1}}(cpk_K,h_K,\overrightarrow{a_K})
$$

Hash in this case can be one of the \textit{Secure Hash Algorithms} in the SHA-2 family. The credential hash is a unique representation of the public key and the delegated attributes at any level. Since the signature includes the credential hash, signature verification would fail if the hash is tampered. The delegator forwards $\sigma_K, h_K, \overrightarrow{a_K}$ to the delegatee. $h_K$ forms a part of credential at every level. The attribute token generated for presentation would now look like

$$
at \leftarrow NIZK \lbrace(  )\rbrace
$$
When generating the attribute token, unlike other attributes, the credential hash value is always revealed to the verifier. There is no danger of someone modifying the hash as that would result in signature verification failure. If the root issuer or any delegator in the chain needs to revoke a credential, he would publish the credential hash in a Black List (BL) of credential hashes. The verifier has to check the credential hash for each level against the BL and if there is a match,  verification should fail.

The instantiation of the NIZK for the attribute token would now look like,


xxxxxx 


xxxxxx

\subsubsection{Session Key Establishment}
In the IoT scenario, once the token generated by the IoT device/User is verified by the IoT service, the next logical step would be to exchange data. In order to securely perform data exchange, both the endpoints should establish a common secret key.

\section{Our Proposal}

\section{Implementation and Results}


\section{Conclusion}
The conclusion goes here.

\bibliographystyle{unsrt}
\bibliography{mybib}

\end{document}


